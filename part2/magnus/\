/*
  C-program to solve the two-dimensional Poisson equation on 
  a unit square using one-dimensional eigenvalue decompositions
  and fast sine transforms

  einar m. ronquist
  ntnu, october 2000
  revised, october 2001
*/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <math.h>
#include <mpi.h>

typedef double Real;

void transpose (Real **bt, Real **b, int m);
Real *createRealArray (int n);
Real **createReal2DArray (int m, int n);
void fst_(Real *v, int *n, Real *w, int *nn);
void fstinv_(Real *v, int *n, Real *w, int *nn);


int main(int argc, char **argv ){


  /* the total number of grid points in each spatial direction is (n+1) */
  /* the total number of degrees-of-freedom in each spatial direction is (n-1) */
  /* this version requires n to be a power of 2 */

 if( argc < 2 ) {
    printf("need a problem size\n");
    return 1;
  }
	int n,m,nn; 
  Real *diag, **b, **bt, *z;
  Real pi, h;
	int nofC,disp;
	

	// Global variables //
  n  = atoi(argv[1]); // nodes : 0,1,2....,n
  m  = n-1;	// number of internal nodes
  nn = 4*n; // number of boundary nodes

  h    = 1./(Real)n;
  pi   = 4.*atan(1.);


	// MPI Initialization //
	int rank, size,i,j;
  int mpi_top_sizes[2]; // dimensions of the processor topology [1,size]
  int mpi_top_coords[2]; // each processors coordinates [0,rank-1]

	MPI_Status status;
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &size);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);

	int sendcounts[size];
	int sdispls[size];
  // setup topology
	
  mpi_top_sizes[0] = 1; // Set number of processors in north-south direction
	mpi_top_sizes[1] = size; // Set number of processors in east-west direction
  int periodic[2] = {0, 0};
  MPI_Comm comm;  
  MPI_Cart_create(MPI_COMM_WORLD, 2, mpi_top_sizes, periodic, 0, &comm); //distributing the processors 
	//variables:  comunicator , #dims,dims, periodicity, reordering?, comm
  MPI_Cart_coords(comm, rank, 2, mpi_top_coords); // making each processor aware of where they work
  /*printf (" rank = %i, coordinates = [%i,%i] \n",rank,mpi_top_coords[0],mpi_top_coords[1]);*/

	nofC = m/size; // number of columns belonging to each processor 
	disp = nofC*rank; // the displacement of each processor
	for(i = 0;i<size;i++){
		sendcounts[i] = nofC; // a vector with the number of columns of each process
		sdispls[i] = i*nofC;
	}
	sendcounts[size-1]+=m%size; 
	if (rank==size-1) nofC += m%size; // the last processor is distributed the remainding columns
	/*printf(" process number %i have %i columns ",rank,nofC);*/
	for(i = 0;i<size;i++){
	sdispls[i] *= nofC; // The displacement vector now contains the unique displacement of each data package.
	sendcounts[i] *= nofC; // the vector now contains the amount of data to be sent and recieved unique for each process!! 
	}

	// PRINTING STUFF //
	if(rank==1){
		printf("\n");
		printf("sendcounts: \n");
	for (i = 0; i<size; i++){
		printf(" %i ",sendcounts[i]);
	}
	printf("\n");
	printf("displacements: \n");
	for (i = 0; i<size; i++){
		printf(" %i ",sdispls[i]);
	}
	printf("\n");
	}

	/*printf (" rank = %i, number of columns = %i \n",rank,nofC);*/
	/*printf (" rank = %i, start and end of columns = %i - %i \n",rank,disp,disp+nofC-1);*/
	
  b    = createReal2DArray (m,nofC); // creating the b-matrix belonging to each processor
  diag = createRealArray (nofC);    // creating the 
  bt   = createReal2DArray (nofC,m); //transposed b-matrix
  z    = createRealArray (nn);
	// Distributing the eigenvalues //
	for (i = 0; i<nofC; i++){
		diag[i] = 2.*(1.-cos((disp+i+1)*pi/(Real)n));}
	
	// Distributing the function values//
	for (i = 0; i<m; i++){ // rows
		for (j = 0; j<nofC; j++){ //columns
			//b[i][j] = pow(h,2);}} // Need to add a function here!! 
			b[i][j] =j*m+i+30*rank ;}} // Need to add a function here!! 

	// Printing the b-matrix // 
	if(rank==4){
		for(i = 0;i<m;i++){
			printf(" \n ");
			for(j = 0;j<nofC;j++){
			printf(" %f ",b[i][j]);}}}
	printf("\n");
	
	// Testing fortran functions //
	/*for (i = 0; i<nofC; i++){*/
		/*fst_(b[i], &n, z, &nn); }*/


	// now the transposing // 
	// Transposing locally //
	for (i = 0; i<m; i++){ // rows
		for (j = 0; j<nofC; j++){ //columns
			bt[j][i] = b[i][j];}} 
		
	// Printing the bt-matrix // 
	if(rank==4){
		for(i = 0;i<nofC;i++){
			printf(" \n ");
			for(j = 0;j<m;j++){
			printf(" %f ",bt[i][j]);}}}
	printf("\n");
	
	// Now, all processes have a matrix ready to be sent.  	
	// sending using all_to_allv
	//
	MPI_Alltoallv(b[0], sendcounts,
										sdispls, MPI_DOUBLE, bt[0],
										sendcounts, sdispls, MPI_DOUBLE,
										MPI_COMM_WORLD);
	// Printing the bt-matrix // 
	if(rank==2){
		for(i = 0;i<nofC;i++){
			printf(" \n ");
			for(j = 0;j<m;j++){
			printf(" %f ",bt[i][j]);}}}
	printf("\n");

	// Transposing locally //
	for (i = 0; i<m; i++){ // rows
		for (j = 0; j<nofC; j++){ //columns
			b[i][j] = b[j][i];}} 
	
	
	MPI_Finalize();

	return 0;
}

void transpose (Real **bt, Real **b, int m)
{
  int i, j;
  for (j=0; j < m; j++) {
    for (i=0; i < m; i++) {
      bt[j][i] = b[i][j];
    }
  }
}

Real *createRealArray (int n)
{
  Real *a;
  int i;
  a = (Real *)malloc(n*sizeof(Real));
  for (i=0; i < n; i++) {
    a[i] = 0.0;
  }
  return (a);
}

Real **createReal2DArray (int n1, int n2)
{
  int i, n;
  Real **a;
  a    = (Real **)malloc(n1   *sizeof(Real *));
  a[0] = (Real  *)malloc(n1*n2*sizeof(Real));
  for (i=1; i < n1; i++) {
    a[i] = a[i-1] + n2;
  }
  n = n1*n2;
  memset(a[0],0,n*sizeof(Real));
  return (a);
}
